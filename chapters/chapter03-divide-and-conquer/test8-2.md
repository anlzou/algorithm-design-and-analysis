<!--
 * @Date        : 2020-05-02 20:37:47
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-06-01 23:31:59
 * @FilePath    : \algorithm-design\chapters\chapter03-divide-and-conquer\test8-2.md
 * @Describe    : 
 -->
 
## 题目地址
3.2 求解排序问题

## 题目描述

问题：
```
#1
快速排序

#2
归并排序

```
分治法的一般算法设计模式如下：
```c++
divide-and-conquer(P){
    if |P| <= n0 return adhoc(P);
    将 P 分解为较小的子问题 P1、P2、...、Pk;
    for(i = 1; i <= k; i++)                 //循环处理 k 次
        yi = divide-and-conquer(Pi);        //递归解决 Pi
    return merge(yi, y2, ..., yk);          //合并子问题
}
```

## 思路
#1 快速排序

快速排序的基本思想是在待排序的 n 个元素中任取一个元素（通常取第一个元素）作为基准，把该元素放入最终位置后，整个数据序列被基准分割成两个子序列，所有小于基准的元素放置在前子序列中，所有大于基准的元素放置在后子序列中，并把基准排在这两个子序列的中间，这个过程称为划分。然后对连个子序列分别重复上述过程，直到每个子序列内只有一个元素或空为止。

#1 归并排序

归并排序的基本思想是首先将 a[0...n-1]看成 n 个长度为 1 的有序表，将相邻的 k(K>=2) 个有序子表成对归并，得到 n/k 个长度为 k 的有序子表；然后再将这些有序子表继续归并，得到 n/k^2 个长度为 k^2 的有序子表，如此反复进行下去，最后得到一个长度为 n 的有序表。由于整个排序结果放在一个数组中，所以不需要特别进行合并操作。

## 代码
#1、2
[exp3-2.cpp](./code/exp3-2.cpp)

## 复杂度分析

#1、2
- 平均时间复杂度：O(nlog2n)
- 空间复杂度：O(n)