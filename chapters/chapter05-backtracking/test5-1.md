<!--
 * @Date        : 2020-05-02 20:37:47
 * @LastEditors : anlzou
 * @Github      : https://github.com/anlzou
 * @LastEditTime: 2020-06-06 22:25:48
 * @FilePath    : \algorithm-design\chapters\chapter05-backtracking\test5-1.md
 * @Describe    : 
 -->
 
## 题目地址
8.1 回溯法概述

## 题目描述

问题：
```
#1

使用回溯法非递归求解下列象棋算式中不同的棋子代表的数值
        兵 炮 马 卒
   +    兵 炮 车 卒
   ————————————————
     车 卒 马 兵 卒

#2

有一个含 n 个整数的数组 a，所有元素均不相同，设计一个算法求其所有子集（幂集，个数为2^n）。

#3

设计一个算法在 1、2、...、9（顺序不能变）数字之间插入 + 或 - 或什么都插入，使得计算结果总是 100 的程序，并输出所有的可能性。

例如 1+2+34-5+67-8+9=100
```

## 思路
> 非递归回溯框架
```cpp
int x[x];                                          // x存放解向量，全局变量
void backtrack(int n){                             // 非递归框架
    int i = 1;                                     // 根结点层次为 1
    while(i >= 1){                                 // 尚未回溯到头
        if(ExisSubNode(t)){                        // 当前结点存在子结点
            for(j = 下界; j <= 上界; j++){          // 对于子集树，j从0到1循环
                x[i]取一个可能的值;
                if(constraint(i) && bound(i)){     // x[i]满足约束条件和界限函数
                    if(x是一个可行解)
                        输出 ;
                    else i++;                      // 进入下一层
                }
            }
        }else i--;                                 // 不存在子结点，返回上一层，即回溯
    }
}
```
说明：算法中的变量 i 十分重要，它对应解空间的第 i 层的某个结点，也就是为整个解向量 X 的第 i 步选择一个合适的分量 xi。

> 递归回溯框架

解空间为**子集树**的递归回溯框架如下：
```cpp
int x[n];                                   // x 存放解向量，为全局变量
void backtrack(int i){                      // 求解子集树的递归框架
    if(i > n){                              // 搜索到叶子结点，输出一个可行解
        输出结果;
    }else{
        for(j = 下界; j <= 上界; j++){       // 用 j 枚举 i 所有可能的路径
            x[i] = j;                       // 产生一个可能的解分量
            ...                             // 其他操作
            if(constraint(i) && bound(i)){
                backtrack(i+1);             // 满足约束条件和界限函数，继续下一层
            }
        }
    }
}
```
采用上述算法框架需要注意以下几点：
1. i 从 1 开始调用上述回溯算法框架，此时结点为第 1 层，叶子结点为第 n+1 层，当然 i 也可以从 0 开始，这样根结点为第 0 层，叶子结点为第 n 层，所以需要将上述代码中的 <code>if(i > n)</code> 改为 <code>if(i >= n)</code>。
2. 在上述框架中通过 for 循环用 j 枚举 i 的所有可能路径，如果扩展路径只有两条，可以改为两次递归调用（如求解 0/1 背包问题、子集合问题等都是如此）。
3. 这里回溯框架只有 i 一个参数，在实际应用中可以根据具体情况设置多个参数。

解空间为**排列树**的递归回溯框架如下：
```cpp
int x[n];                                   // x 存放解向量，并初始化
void backtrack(int i){                      // 求解排列树的递归框架
    if(i > n){                              // 搜索到叶子结点，输出一个可行解
        输出结果;
    }else{
        for(j = i; j <= n; j++){            // 用 j 枚举 i 的所有可能路径
            ...                             // 第 i 层的结点选择 x[j] 的操作
            swap(x[i], x[j]);               // 为保证排列中的每个元素不同，通过交换来实现
            if(constraint(i) && bound(i)){
                backtarck(i+1);             // 满足约束条件和界限函数，计入下一层
            }
            swap(x[i], x[j]);               // 恢复状态
            ...                             // 第 i 层的结点选择 x[j] 的恢复操作
        }
    }
}
```
注意点：与解空间树为子集树的递归回溯框架相同。

#1

这里的解向量为 (a,b,c,d,e)，分别表示兵、炮、马、卒和车的取值。

采用多重循环来试探各棋子不同的取值情况，逐一判断它们是否满足算式的条件；为了避免同一数字被重复使用，可设立布尔数组 dig，当 dig[i](0 <= i <= 9)值为 0 时表示数字 i 没有被使用，为 1 时表示数字 i 已经被使用。

例如对于棋子兵，先试探它取值 a，让 dig[a] = 1 表示其它棋子不能再取值 a，继续其它棋子的试探，当不成功（放弃当前候选解）或输出一个解（找到一个解）后进行回溯，让 dig[a] = 0 表示其它棋子可以取值 a，即再试探其它候选解。

#2

显然本问题的解空间树为子集树，每个元素只有两种扩展，要么选择，要么不选择。采用深度优先搜索思路，解向量为 x[ ]，x[i] = 0 表示不选择 a[i]，x[i] = 1 表示选择 a[i]。用 i 扫描数组 a，也就是说问题的初始状态是(i = 0, x 的元素为 0)，目标状态是(i = n, x 为一个解)。从状态(i, x)可以扩展出两个状态：
1. 不选择 a[i] 元素→下一个状态为(i+1, x[i] = 0)。
2. 选择 a[i]元素→下一个状态为(i+1, x[i] = 1)。

这里 i 总是递增的，所以不会出现状态重复的情况。

#3

用数组 a 存放 1~9 的整数，用字符数组 op 存放插入的运算符，op[i] 表示在 a[i] 之前插入的运算符。采用回溯法产生和为 100 的表达式，op[i] 只能取值 +、- 或者空格（不同于上一个例子，这里是三选一）。

设计函数fun(op, sum, prevadd, a, i)，其中 sum 记录考虑整数 a[i] 时前面表达式计算的整数和（初始值为 a[0]），preadd 记录前面表达式中的一个数值（初始值为 a[0]），i 从 1 开始到 8 结束，如果 sum = 100 ，得到一个解。

## 关键点
- **解空间**(solution space) ≡ **解空间树** ≡ **状态空间树**(state space tree)

## 代码
#1
- [exp5-1-1.cpp](./code/exp5-1-1.cpp)

#2
- [exp5-1-2.cpp](./code/exp5-1-2.cpp)

#3
- [exp5-1-3.cpp](./code/exp5-1-3.cpp)

## 补充
> <code>memset()</code>

语法:
```cpp
  #include <string.h>
  void *memset( void *buffer, int ch, size_t count );
```
功能: 函数拷贝ch 到buffer 从头开始的count 个字符里, 并返回buffer指针。 memset() 可以应用在将一段内存初始化为某个值。例如：
```cpp
    memset( the_array, '\0', sizeof(the_array) );
```
这是将一个数组的所以分量设置成零的很便捷的方法。

> <code>vector</code>

Vectors 包含着一系列连续存储的元素,其行为和数组类似。

```cpp
Constructors    //构造函数 
Operators       //对vector进行赋值或比较 
assign()        //对Vector中的元素赋值 
at()            //返回指定位置的元素 
back()          //返回最末一个元素 
begin()         //返回第一个元素的迭代器 
capacity()      //返回vector所能容纳的元素数量(在不重新分配内存的情况下） 
clear()         //清空所有元素 
empty()         //判断Vector是否为空（返回true时为空） 
end()           //返回最末元素的迭代器(译注:实指向最末元素的下一个位置) 
erase()         //删除指定元素 
front()         //返回第一个元素 
get_allocator() //返回vector的内存分配器 
insert()        //插入元素到Vector中 
max_size()      //返回Vector所能容纳元素的最大数量（上限） 
pop_back()      //移除最后一个元素 
push_back()     //在Vector最后添加一个元素 
rbegin()        //返回Vector尾部的逆迭代器 
rend()          //返回Vector起始的逆迭代器 
reserve()       //设置Vector最小的元素容纳数量 
resize()        //改变Vector元素数量的大小 
size()          //返回Vector元素数量的大小 
swap()          //交换两个Vector 

```

## 复杂度分析

- 时间复杂度：O( )
- 空间复杂度：O( )